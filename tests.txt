start creating player and then disconnect

start creating player but another client makes one first

create player in view of another client

login/disconnect from player in view of another client

move in/out of view of another client

different items:

seeds	- stack
fruits	- stack spoil
bags	- bag <-> stack container
tool belt	- cnt <-> stck cnt
clothes dummy	- block cnt
stackable wood boxes
non-stackable clay boxes
items that take full cell	- blck
items that take multiple cells

each cell can have only one item key
	for stacks, len allowed in cell is custom
	for allowing player movement, different len

considering making container ids as global...

bags can have any item as long as volumes fit

map.newitem( loc ,new items.Dewd_pck(1) )
new items.Dewd_pck(1).spawnonmap( map ,loc )
sends[[ "maps","g" ], "newitem" ,[ [x,y] ,[ "dewd_pck" , {len:1} ]]]

map.obj.g(loc).item.unpack( map ,loc )
map.unpackitem( loc )
sends[[ "maps","g" ], "unpackitem" ,[ [x,y] ]]

if you're changing item or container, must do it through its' own container

adding things must return how many things actually added

?adding things can change container id anywhere in the path
	that's why the given path must be updated to new path

addings things must send the location of item over network

adding things to empty containers on map can push other objects to
	neighboring cells

when moving items, items can move inside or outside visual range

if an action sent to client creates side effects, let the client handle them

some actions client initiates might not be possible,
	there should be a way to test if action is effective before doing it
	that means action will be broken down in 3 layers:
	1. do action without test
	2. test
	3. do action with test

when changing any item, client-server updates need to happen,

whatever I do to server, if clients need to updated, a path
	object will be created?

These are the options of where an item can lie. Each has special rules:
	1. In a bag.
	2. In a custom container (like player)
	3. On a map cell.

	so when changing an item, dad can be changed too and each
	dad has different rules.
	So check container, AND the dad every time adding to cnt

stack.del( item ,len )
{
	this.len	-= len
	return this.len <= 0
}

cnts.del( item ,len )
{
	delete this.o[item.id]
	return ! Objet.keys(this.o).length
}

bag.delitem( nav ,_i, item ,len )
{
	if( this.inv[item.gkey()].del( item ,len ))	delete this.inv[key]
	if( this.isempty() )	nav.call( -1 ,"cnt2stck", this )
}
cell.delitem( nav ,_i ,item ,len )
{
	if( ! item.isstack() || item.del( len ))	delete nav.dad(_i).obj.g(this).item

	nav.send( "delitem" ,_i ,item ,len )
}

bag.cnt2stack( nav ,cnt )
{
	this.additem( nav ,cnt.newstack() )
	this.delitem( nav ,cnt )
}
map.cnt2stack( loc )
{
	cell.item	=cell.item.newstack()
}

Bag.canfit( nav ,_i ,item )
{
	var canfit	=//calculate if bag can fit

	return canfit && ( ! nav.dad(_i).isbag() || nav.exdad(_i, "canfit" ,item ))
}
bag.canadditem( nav ,cid ,item )
{
	return this.canfit( nav ,cid ,item )
}
stckcnt.canadditem( nav ,_i ,item )
{
	return This.Cnt.canfit( nav ,_i ,item ) &&

			( ! nav.dad(_i).iscell() || nav.exdad( _i, "canpushitem" ))
}
map.canadditem( loc ,item )
{
	if( item.isstack() )
	{
		return this.canpushitem( loc )
	}
	return true
}

map.additem( loc ,item ,act )
{
	this.obj.s(loc).item	=item

	if( act )	act.send( )
}

bag.additem( nav ,item )
{
	if( ! this.inv[item.gkey()] )
	{
		this.inv[key]	=item.newkeyprop()
	}
	this.inv[key].add( item )
}

stackcnt.additem([ game,chain,cid ], item )
{
	var cnt	=this.newcnt()
	cnt.additem( nav ,item )
	this.del(1)
	game.$2( chain,cid -1, "stack2cnt" ,this ,cnt )
}

bag.stack2cnt([ game,chain,cid ], stackcnt ,cnt )
{
	this.additem( nav ,)

	if( stackcnt.isempty() )	delete this.inv[stackcnt.gkey()]

	if( ! this.inv[cnt.gkey()] )	this.inv[ckey]	=cnt.newkeyprop()

	this.inv[ckey].add( cnt )
}
map.stack2cnt( loc ,stackcnt ,cnt )
{
	if( ! stackcnt.isempty() )	this.pushitem( loc )

	this.item	=cnt
}

path.canadditem( item )
{

}

cl: movitem [pls,pl,bpack,id,bag,id] seeds 1 [maps,loc,bag_vc]
game.movitem(new Nav([ pls,pl,bpack,bag ]), item ,len ,new Nav([ maps,loc,bag_vc ]), mover )

new Nav([ pls,pl,bpack,bag ]).exef("mov", seeds ,1 ,new Nav([maps,loc,bag_vc]))
movitem( from, f_i ,item, to ,to_i )
{
	if( ! to.exe( to_i ,"canadditem" ,item ))	return

	if( from.iscnt() )
	{

	}
}

gm[[ "maps",[x,y,z] ], "newitem" ,[ "bag_vc" ,{len:3} ]]
new Nav([ maps ,loc ]).exef("newitem" ,item )
act.newitem()
{
	if( this.dest)
	if( map.canadditem( loc ,item ))	map.additem( loc ,item ,this )
}

game.$( [maps,loc] ,"newitem" ,item )
obj.newitem_test([ game ,path ,2 ], item )
srv[[ "maps",[x,y,z] ], "newitem" ,[ "bag_vc" ,{len:3} ]]

gm[[ "maps",[x,y,z],"bag_vc" ], "add" ,2 ]
game.$( [maps,loc,item] ,"add" ,2 )
stack.add_test([ game ,path ,3 ], 2 )
srv[[ "maps",[x,y,z],"bag_vc" ], "add" ,2 ]

stackcnt.additem_test( [game,[ maps,loc,stackcnt ],3], new items.Bag_vc(3) )
{
	if( this.canadditem( hp ,item ))	return this.additem( hp ,item )
	else	return false
}
stackcnt.canadditem([ game,chain,cid ], item )
{
	if( game.$2( chain ,cid-1 ,"canadditem" ,this ,item ,len ))
}
map.canadditem( loc ,cnt ,item ,len )
{
	
}

map.stack2cnt( loc ,stackcnt ,cnt )
{
	if( ! stackcnt.isempty() )	this.pushitem( loc )

	this.item	=cnt
}
srv.stackcnt.additem([ game,chain,cid ], item )
{
	super.additem( hp ,item )

	game.srv.send( hp ,"additem", item )
}
srv[[ "maps",[x,y,z],"item","bag_vc" ], "additem" ,[ "bag_vc" ,{len:3} ]]

pl.sends[ "movitem" ,[[ "pls","gavriel","backpack",bid ], "seed" ,1 ,[ "maps",[x,y,z],"bag",bid,"bag_vc" ]]]
pl.canmovitem([ pls,pl,bpck ], item ,len ,[ maps,loc,bag,bag_vc ])
{
	if( from[0] instanceof Pls )
	{
		if( from[1].loc.dist( this.loc ))
	}
	if( to[0] instanceof Maps )
	{
		if( to[1].dist( this.loc ))
	}
	if( game.$( to ,"canadd" ,item ,len ))
}
cnt.canadd([ game ,chain ,cid ], item ,len )
{
	if( game.$2( chain,cid -1, "cancntadd" ,this ,item ,len ))
}
game.movitem( from ,item ,len ,to )
{
	game.$( from ,"delitem" ,item ,len )	//if cnt becomes stack

	game.$( to ,"additem", item ,len )	//if stck becomes cnt
}



pl.sends[ "movitem" ,[[ [x,y,z] ,"bag" ], "bag_vc" ,1 ,[ "pl" ,"backpack" ]]]
srvsends[ "movitem" ,[[ "gavriel" ], {item:["bag_vc",{len:1}]} ,null ,
						[ [0,0,0] ,"bag" ] ]]

var path	=[ loc ,"bag_vc" ]
added	=map.obj.g(loc).item.inv.bag_vc.newitem( new items.Bag_vc(3) ,map ,path )
added	=map.newitem2cnt( path ,new items.Bag_vc(3) )

containers inside custom container are always used
	so when an empty used container is put somewhere else,
	this container needs to transform to stack,
	and vice versa

pl sends[ "movitem" ,[[ "pl" ], "backpack" ,1 ,[ [x,y,z] ]]]



// send to those who view the inside of the bag
srv sends[ "newitem" ,[  ]]

// changes path to [ loc ,"bag" ,id ]

cell{ item: bag{ bag_vc{2} ,bag{ bag_vc{3} } }}

bags can have empty containers and used containers

bags can have a number of used containers

pl sends[ "mov_item" ,[[ [0,0,0] ], "bag" ,[ [0,1,0] ]]]

pl sends[ "mov_item" ,[[ [0,1,0] ,"bag" ], "bag" ,id ,[ "gavriel" ,"bckpck" ]]]

pl sends[ "mov_item" ,[[ [0,1,0] ,"bag" ], "bag" ,id ,[ "gavriel" ,"bckpck" ]]]

pl sends[ "mov_item" ,[[ [0,2,0] ,"bag" ], "cucseed" ,14 ,[ "gavriel" ,"bckpck" ,"bag", id ]]]

pl sends[ "mov_item" ,[[ "gavriel" ,"bckpck" ,"bag" ,id ]]]



pl sends[ "mov_thing" ,[[ "gavriel" ,"bckpck" ,"belt" ,2 ], "seedbag" ,1 ,[ "gavriel" ]]]

pl sends[ "plant" ,[[ "gavriel" ,"seedbag" ,1 ], "cuc_seed", 8 , [14,13,0] ]]


bag.mov()

new Nav([pls,pl,bpack,bag]).exef("mov", seeds ,1 ,new Nav([maps,loc,bag_vc]))


class Pl extends Holder
{
	[allowed]
	inv
	ispl()
	[key]
}

class Rcpt extends 


class 
start creating player and then disconnect

start creating player but another client makes one first

create player in view of another client

login/disconnect from player in view of another client

move in/out of view of another client

all items must have static key prop

basic items are identical to each other so have len property

non empty containers are unique so must have id property

containers must contain multiple items. their access is determined by
	[key,id] pair

each cell can have only one [key,id] paired item


different items:

seeds
fruits
bags
tool belt
clothes dummy
stackable wood boxes
non-stackable clay boxes
items that take full cell
items that take multiple cells


each cell can have only one item
	for stacks, len allowed in cell is custom
	for allowing player movement, different len

for containers, there's a container class which manages their different ids

cell.bags.g(id)

because containers can change types based on items added or removed,
	the methods must exist on the root container like cell or player

bags can have any item as long as volumes fit

map.newitem( loc ,new items.Dewd_pck(1) )
map.obj.g(loc).item.unpack( map ,loc )
map.unpackitem( loc )

adding things must return how many things actually added

adding things can change container id anywhere in the path
	that's why the given path must be updated to new path

addings things must send the location of item over network

adding things to empty containers on map can push other objects to
	neighboring cells

when moving items, items can move inside or outside visual range

if an action sent to client creates side effects, let the client handle them

sends[ "newitem" ,[ path to container[] , ]]

map.newitem( loc ,new items.Bag_vc(3) )
new items.Bag_vc(3).spawnonmap( map , loc )

srv sends[ "newitem" ,[[ [0,0,0] ], "bag_vc" ,{len:3} ]]

map.add2stack( loc  ,2 )
item.

srv sends[ "add2stack" ,[[ [0,0,0] ], "bag_vc",{len:5}]} ,2 ]]

added	=map.obj.g(loc).item.newitem( new items.Bag_vc(3) ,map ,[ loc ])
added	=map.newitem2cnt([ loc ],new items.Bag_vc(3) )

srv sends[ "srv_movitem" ,[[ [1,0,0] ], {item:["bag_vc",{len:4}]} ,null ,
						[ [0,0,0] ], {item:["bag_vc",{len:1}]} ]]
					 	
srv sends[ "srv_newitem" ,[[ [0,0,0] ,"bag" ], {inv:{bag_vc:{len:3}}} ]]

pl.movitem([ loc ,"item" ,"bag_vc" ], 1, [ 1 ])

srv sends[ "movitem" ,[[ "gavriel" ], {item:["bag_vc",{len:1}]} ,null ,
						[ [0,0,0] ,"bag" ] ]]

var path	=[ loc ,"bag_vc" ]
added	=map.obj.g(loc).item.inv.bag_vc.newitem( new items.Bag_vc(3) ,map ,path )
added	=map.newitem2cnt( path ,new items.Bag_vc(3) )

// send to those who view the inside of the bag
srv sends[ "newitem" ,[  ]]

// changes path to [ loc ,"bag" ,id ]

cell{ item: bag{ bag_vc{2} ,bag{ bag_vc{3} } }}

bags can have empty containers and used containers

bags can have a number of used containers

pl sends[ "mov_item" ,[[ [0,0,0] ], "bag" ,[ [0,1,0] ]]]

pl sends[ "mov_item" ,[[ [0,1,0] ,"bag" ], "bag" ,id ,[ "gavriel" ,"bckpck" ]]]

pl sends[ "mov_item" ,[[ [0,1,0] ,"bag" ], "bag" ,id ,[ "gavriel" ,"bckpck" ]]]

pl sends[ "mov_item" ,[[ [0,2,0] ,"bag" ], "cucseed" ,14 ,[ "gavriel" ,"bckpck" ,"bag", id ]]]

pl sends[ "mov_item" ,[[ "gavriel" ,"bckpck" ,"bag" ,id ]]]



pl sends[ "mov_thing" ,[[ "gavriel" ,"bckpck" ,"belt" ,2 ], "seedbag" ,1 ,[ "gavriel" ]]]

pl sends[ "plant" ,[[ "gavriel" ,"seedbag" ,1 ], "cuc_seed", 8 , [14,13,0] ]]
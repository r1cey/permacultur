start creating player and then disconnect

start creating player but another client makes one first

create player in view of another client

login/disconnect from player in view of another client

move in/out of view of another client

different items:

seeds	- stack
fruits	- stack spoil
bags	- bag <-> stack container
tool belt	- cnt <-> stck cnt
clothes dummy	- block cnt
stackable wood boxes
non-stackable clay boxes
items that take full cell	- blck
items that take multiple cells

each cell can have only one item key
	for stacks, len allowed in cell is custom
	for allowing player movement, different len

considering making container ids as global...

bags can have any item as long as volumes fit

map.newitem( loc ,new items.Dewd_pck(1) )
new items.Dewd_pck(1).spawnonmap( map ,loc )
sends[[ "maps","g" ], "newitem" ,[ [x,y] ,[ "dewd_pck" , {len:1} ]]]

map.obj.g(loc).item.unpack( map ,loc )
map.unpackitem( loc )
sends[[ "maps","g" ], "unpackitem" ,[ [x,y] ]]

if you're changing item or container, must do it through its' own container

adding things must return how many things actually added

?adding things can change container id anywhere in the path
	that's why the given path must be updated to new path

addings things must send the location of item over network

adding things to empty containers on map can push other objects to
	neighboring cells

when moving items, items can move inside or outside visual range

if an action sent to client creates side effects, let the client handle them

when changing any item, client-server updates need to happen,
	therefore changing of items must happen in map or player

whatever I do to server, if clients need to updated, a path
	object will be created.

gm[[ "maps",[x,y,z] ], "newitem" ,[ "bag_vc" ,{len:3} ]]
game.$( [maps,loc] ,"newitem" ,item )
obj.newitem([ path ,2 ], item )
srv[[ "maps",[x,y,z] ], "newitem" ,[ "bag_vc" ,{len:3} ]]

gm[[ "maps",[x,y,z],"item","bag_vc" ], "add" ,2 ]
game.$( [maps,loc,item] ,"add" ,2 )
item.add([ path ,3 ], 2 )
srv[[ "maps",[x,y,z],"item","bag_vc" ], "add" ,2 ]

stack.newitem([ maps,loc,stack ], new items.Bag_vc(3) )
srv[[ "maps",[x,y,z],"item","bag_vc" ], "newitem" ,[ "bag_vc" ,{len:3} ]]

pl.sends[ "movitem" ,[[ [x,y,z] ,"bag_vc" ], "bag_vc" ,1 ,[ "pl" ,"backpack" ]]]
srvsends[ "movitem" ,[[ "gavriel" ], {item:["bag_vc",{len:1}]} ,null ,
						[ [0,0,0] ,"bag" ] ]]

var path	=[ loc ,"bag_vc" ]
added	=map.obj.g(loc).item.inv.bag_vc.newitem( new items.Bag_vc(3) ,map ,path )
added	=map.newitem2cnt( path ,new items.Bag_vc(3) )

containers inside custom container are always used
	so when an empty used container is put somewhere else,
	this container needs to transform to stack,
	and vice versa

pl sends[ "movitem" ,[[ "pl" ], "backpack" ,1 ,[ [x,y,z] ]]]



// send to those who view the inside of the bag
srv sends[ "newitem" ,[  ]]

// changes path to [ loc ,"bag" ,id ]

cell{ item: bag{ bag_vc{2} ,bag{ bag_vc{3} } }}

bags can have empty containers and used containers

bags can have a number of used containers

pl sends[ "mov_item" ,[[ [0,0,0] ], "bag" ,[ [0,1,0] ]]]

pl sends[ "mov_item" ,[[ [0,1,0] ,"bag" ], "bag" ,id ,[ "gavriel" ,"bckpck" ]]]

pl sends[ "mov_item" ,[[ [0,1,0] ,"bag" ], "bag" ,id ,[ "gavriel" ,"bckpck" ]]]

pl sends[ "mov_item" ,[[ [0,2,0] ,"bag" ], "cucseed" ,14 ,[ "gavriel" ,"bckpck" ,"bag", id ]]]

pl sends[ "mov_item" ,[[ "gavriel" ,"bckpck" ,"bag" ,id ]]]



pl sends[ "mov_thing" ,[[ "gavriel" ,"bckpck" ,"belt" ,2 ], "seedbag" ,1 ,[ "gavriel" ]]]

pl sends[ "plant" ,[[ "gavriel" ,"seedbag" ,1 ], "cuc_seed", 8 , [14,13,0] ]]